module Generate where

import Prelude

import Control.Alt ((<|>))
import Control.Monad.Except as ExceptT
import Control.Parallel (parTraverse)
import Core (FetchResult(..), MyError(..), NixPrefetchGitResult, Package, Repo(..), Revision(..), SHA256(..), URL(..), Version(..), exit, readPackage, spagoPackagesNix)
import Data.Array as Array
import Data.Bifunctor (lmap)
import Data.Either (Either(..))
import Data.Maybe (Maybe(..))
import Data.String as String
import Data.Traversable (traverse, traverse_)
import Data.Validation.Semigroup (V(..), toEither)
import Effect.Aff (Aff)
import Effect.Class.Console (error, log)
import Node.ChildProcess as CP
import Node.Encoding (Encoding(..))
import Node.FS.Aff as FS
import Simple.JSON as JSON
import Simple.JSON.Utils (printMultipleErrors)
import Sunde as S

-- | Magic SHA256 for broken fetches from nix-prefetch-git, see below notes
brokenRepoSHA :: SHA256
brokenRepoSHA = SHA256 "0sjjj9z1dhilhpc8pq4154czrb79z9cm044jvn75kxcjv6v5l2m5"

-- # e.g. when you nix-prefetch-git
-- # when you have a valid reference:
-- $ nix-prefetch-git https://github.com/purescript/purescript-unsafe-coerce.git --rev v4.0.0 --quiet
-- {
--   "rev": "fa6a5ca9b4581c00ee0b8539306a49badb7bee60",
--   "sha256": "0k9255mk2mz6xjb11pwkgfcblmmyvr86ig5kr92jwy95xim09zip",
-- }
-- # when you don't
-- $ nix-prefetch-git https://github.com/purescript/purescript-unsafe-coerce.git --rev v4.0.j0 --quiet
-- {
--   "rev": "refs/heads/fetchgit",
--   "sha256": "0sjjj9z1dhilhpc8pq4154czrb79z9cm044jvn75kxcjv6v5l2m5",
-- }

spagoListPackages :: Aff (Either MyError (Array Package))
spagoListPackages = do
  error "getting packages.."
  output <- S.spawn
    { cmd: "spago"
    , args: [ "ls", "deps", "--json", "--transitive" ]
    , stdin: Nothing
    }
    CP.defaultSpawnOptions

  case output.exit of
    CP.Normally 0 -> do
      let lines = words output.stdout
      error $ "got " <> show (Array.length lines) <> " packages from spago ls deps."
      pure $ traverse readPackage lines
    e -> do
      error "Failed to list packages:"
      error output.stderr
      pure $ Left $ SpagoRunError (show e)
  where
    words :: String -> Array String
    words = String.split (String.Pattern "\n") <<< String.trim

fetchPackage :: Package -> Aff (Either MyError FetchResult)
fetchPackage p@{ repo: Local _ } = pure $ pure $ CantFetchLocal p
fetchPackage p@{ repo: Remote (URL url), version: Version version } = ExceptT.runExceptT do
  output <- ExceptT.lift $ S.spawn
    { cmd: "nix-prefetch-git"
    , args: [ url, "--rev", version, "--quiet" ]
    , stdin: Nothing
    }
    CP.defaultSpawnOptions
  json <- case output.exit of
    CP.Normally 0 -> do
      pure output.stdout
    x -> do
      ExceptT.throwError $ NixPrefetchGitFailed (show x)

  result :: NixPrefetchGitResult <- case JSON.readJSON json of
    Right x -> pure x
    Left e -> ExceptT.throwError $ NixPrefetchGitOutputDeformed (printMultipleErrors e)

  if result.sha256 == brokenRepoSHA
    then ExceptT.throwError $ MissingRevOrRepoResult (show p)
    else pure $ Fetched { package: p, result }

ensureFetchPackage :: String -> Package -> Aff (Either MyError FetchResult)
ensureFetchPackage cacheDir p = do
  exists <- FS.exists path
  if exists
    then do
      error $ "already prefetched " <> p.packageName
      contents <- FS.readTextFile UTF8 path
      case JSON.readJSON contents of
        Right x -> pure $ Right x
        Left e -> pure $ Left $ FileContentsCorrupted p path (printMultipleErrors e)
    else do
      error $ "fetching " <> p.packageName
      result <- fetchPackage p
      case result of
        Left e -> pure $ Left e
        Right fetch -> do
          FS.writeTextFile UTF8 path (JSON.writeJSON fetch)
          pure result
  where
    path = mkPrefetchPath cacheDir p

mkPrefetchPath :: String -> Package -> String
mkPrefetchPath cacheDir { packageName, version: Version version } =
  cacheDir <> "/" <> packageName <> "@" <> version <> ".json"

ensureSetup :: String -> Aff Unit
ensureSetup cacheDir = do
  FS.mkdir cacheDir <|> pure unit

template :: String
template = """# This file was generated by Spago2Nix

{ pkgs ? import <nixpkgs> {} }:

let
  inputs = {
INPUTS
  };

  cpPackage = pkg:
    let
      target = ".spago/${pkg.name}/${pkg.version}";
    in ''
      if [ ! -e ${target} ]; then
        echo "Installing ${target}."
        mkdir -p ${target}
        cp --no-preserve=mode,ownership,timestamp -r ${toString pkg.outPath}/* ${target}
      else
        echo "${target} already exists. Skipping."
      fi
    '';

  getGlob = pkg: ''".spago/${pkg.name}/${pkg.version}/src/**/*.purs"'';

  getStoreGlob = pkg: ''"${pkg.outPath}/src/**/*.purs"'';

in {
  inherit inputs;

  installSpagoStyle = pkgs.writeShellScriptBin "install-spago-style" ''
      set -e
      echo installing dependencies...
      ${builtins.toString (builtins.map cpPackage (builtins.attrValues inputs))}
      echo "echo done."
  '';

  buildSpagoStyle = pkgs.writeShellScriptBin "build-spago-style" ''
      set -e
      echo building project...
      purs compile ${builtins.toString (builtins.map getGlob (builtins.attrValues inputs))} "$@"
      echo done.
  '';

  buildFromNixStore = pkgs.writeShellScriptBin "build-from-store" ''
      set -e
      echo building project using sources from nix store...
      purs compile ${builtins.toString (
        builtins.map getStoreGlob (builtins.attrValues inputs))} "$@"
      echo done.
  '';

  mkBuildProjectOutput =
    { src, purs }:

    pkgs.stdenv.mkDerivation {
      name = "build-project-output";
      src = src;

      buildInputs = [ purs ];

      installPhase = ''
        mkdir -p $out
        purs compile "$src/**/*.purs" ${builtins.toString
          (builtins.map
            (x: ''"${x.outPath}/src/**/*.purs"'')
            (builtins.attrValues inputs))}
        mv output $out
      '';
    };
}
"""

replace :: { from :: String, to :: String } -> String -> String
replace { from, to } = String.replaceAll (String.Pattern from) (String.Replacement to)

printResult :: FetchResult -> String
printResult (CantFetchLocal { packageName, repo })
    = replace { from: "PKGNAME", to: packageName }
  <<< replace { from: "PATH", to: show repo }
    $ """
  # PKGNAME is a Local package in PATH
"""
printResult (Fetched
  { package: { packageName, version: Version version }
  , result: { url: URL url, rev: Revision rev, sha256: SHA256 sha256 }
  })
    = replace { from: "PKGNAME", to: packageName }
  <<< replace { from: "VERSION", to: version }
  <<< replace { from: "URL", to: url }
  <<< replace { from: "REV", to: rev }
  <<< replace { from: "SHA256", to: sha256 }
    $ """
    "PKGNAME" = pkgs.stdenv.mkDerivation {
        name = "PKGNAME";
        version = "VERSION";
        src = pkgs.fetchgit {
          url = "URL";
          rev = "REV";
          sha256 = "SHA256";
        };
        phases = "installPhase";
        installPhase = "ln -s $src $out";
      };
"""

printResults :: Array FetchResult -> String
printResults xs = replace { from: "INPUTS", to: inputs } template
  where inputs = Array.foldMap printResult xs

concatMapM :: forall a b m. Monad m => (a -> m (Array b)) -> Array a -> m (Array b)
concatMapM f xs = Array.concat <$> traverse f xs

chunk :: forall a. Int -> Array a -> Array (Array a)
chunk _ [] = []
chunk n xs | n < 1     = [xs]
           | otherwise = chunk' [] xs
  where
    chunk' acc [] = acc
    chunk' acc rest = chunk' (acc <> [Array.take n rest]) (Array.drop n rest)

generate :: String -> Int -> Aff Unit
generate cacheDir maxProcs = do
  ensureSetup cacheDir
  packages <- exitOnError spagoListPackages
  fetches <- toResult <$> concatMapM (parTraverse (ensureFetchPackage cacheDir)) (chunk maxProcs packages)
  case fetches of
    Left errors -> do
      error "errors from fetching packages:"
      traverse_ (error <<< show) errors
      exit 1
    Right xs -> do
      FS.writeTextFile UTF8 spagoPackagesNix (printResults xs)
      log $ "wrote " <> spagoPackagesNix
      exit 0

  where
    toResult :: forall a b. Array (Either b a) -> Either (Array b) (Array a)
    toResult xs = toEither $ traverse V $ map (lmap pure) xs

    exitOnError :: forall a. Aff (Either MyError a) -> Aff a
    exitOnError aff = do
      result <- aff
      case result of
        Right x -> pure x
        Left e -> do
          error $ show e
          exit 1
